//
//  MultipleChoiceViewController.swift
//  Factor+
//
//  Created by Taehyun Lee on 2015-10-29.
//  Copyright © 2015 LYM. All rights reserved.
//
//  This file is responsible for the Multiple Choice: Factoring mode of the application.
//  In this file, the application generates a quadratic relations to be factored, by using
//  the quadratic class, and making an object of the class. Then multiple choice answers are
//  generated by using the values derived from the quadratic relation.
//
//  This file, as with all other files, is linked to various other View Controllers (screens)
//  such as the Pause screen or the End screen, to enable a progress in the application.
//

import UIKit

class MultipleChoiceViewController: UIViewController {
    
    
    var numQuestions = Int()
    
    @IBOutlet weak var choice1Button: UIButton!       //the following UIButtons represent each of the 4
    @IBOutlet weak var choice2Button: UIButton!       //answer choices, clickable by the user
    @IBOutlet weak var choice3Button: UIButton!
    @IBOutlet weak var choice4Button: UIButton!
    @IBOutlet weak var pauseButton: UIButton!         //the pause button
    @IBOutlet weak var questionLabel: UILabel!        //this UILabel displays the quadratic relation
    @IBOutlet weak var progressMCF: UIProgressView!   //the progress bar, consists of 10 questions
    @IBOutlet weak var nextButton: UIButton!          //the next button, generates next question when
                                                      //clicked
    @IBOutlet weak var coverUpButton: UIButton!       //this appears when an answer is clicked, as a
                                                      //means of disabling other buttons
 
    var quadraticRelation = quadratic() //the quadratic object, which generates a quadratic relation
    var firstFactor: String = ""        //the first factor
    var secondFactor: String = ""       //the second factor
    var choice = [String]()             //this array stores each of the randomly generated answers
                                        //for the multiple choice question
    var rightAnsIndex: Int = 0          //the index in the array that stores the correct answer
    var numCorrect: Int = 0             //the number of questions that were correct
    var question: String = ""           //the variable that stores the question
    var fromPause: Bool = false         //was the "continue" button pressed from the pause menu?
    
    //run this code when the first answer is clicked
    @IBAction func choice1Clicked(sender: AnyObject) {
        if (checkForRightAnswer(1) == true)
        {
            choice1Button.backgroundColor = UIColor.greenColor()     //if correct, set the button to green
            numCorrect++
        }
        else //if choice 1 is incorrect
        {
            choice1Button.backgroundColor = UIColor.redColor()       //if incorrect, set the button to red
            
            //then check every other index to see if they are correct, and highlight the correct answer in green
            if (checkForRightAnswer(2) == true) {
                choice2Button.backgroundColor = UIColor.greenColor()
            }
            
            else if (checkForRightAnswer(3) == true) {
                choice3Button.backgroundColor = UIColor.greenColor()
            }
            
            else if (checkForRightAnswer(4) == true) {
                choice4Button.backgroundColor = UIColor.greenColor()
            }
        }
        
        nextButton.hidden = false       //show the 'next' button
        pauseButton.hidden = true       //hide the 'pause' button to prevent the question from resetting
        coverUpButton.hidden = false    //show the 'coverUp' button which is to prevent other answer buttons from
                                        //being clicked once the question is answered
        
        /* the following lines of codes commented out is the timer object in XCode, and may be used later for 
           when the timed game mode getas implemented
        
        //http://stackoverflow.com/questions/27990085/nstimer-how-to-delay-in-swift
        let seconds = 5.0
        let delay = seconds * Double(NSEC_PER_SEC)  // nanoseconds per seconds
        let dispatchTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delay))
        
        dispatch_after(dispatchTime, dispatch_get_main_queue(), {
            
            // here code perfomed with delay (5 seconds in this case)
            
            self.resetColours()
            self.changeProgress()
            self.makeQuestion()
            self.makeMultipleChoice()
            self.selectionSort()
            self.assignToButtons()
            
        })

        */
    }
    @IBAction func choice2Clicked(sender: AnyObject) {
        if (checkForRightAnswer(2) == true)
        {
            choice2Button.backgroundColor = UIColor.greenColor()
            numCorrect++
        }
        else
        {
            choice2Button.backgroundColor = UIColor.redColor()
            
            if (checkForRightAnswer(1) == true) {
                choice1Button.backgroundColor = UIColor.greenColor()
            }
                
            else if (checkForRightAnswer(3) == true) {
                choice3Button.backgroundColor = UIColor.greenColor()
            }
                
            else if (checkForRightAnswer(4) == true) {
                choice4Button.backgroundColor = UIColor.greenColor()
            }
        }
        nextButton.hidden = false
        pauseButton.hidden = true
        coverUpButton.hidden = false
    }
    @IBAction func choice3Clicked(sender: AnyObject) {
        if (checkForRightAnswer(3) == true)
        {
            choice3Button.backgroundColor = UIColor.greenColor()
            numCorrect++
        }
        else
        {
            choice3Button.backgroundColor = UIColor.redColor()
            
            if (checkForRightAnswer(1) == true) {
                choice1Button.backgroundColor = UIColor.greenColor()
            }
            
            else if (checkForRightAnswer(2) == true) {
                choice2Button.backgroundColor = UIColor.greenColor()
            }
            
            else if (checkForRightAnswer(4) == true) {
                choice4Button.backgroundColor = UIColor.greenColor()
            }
        }
        nextButton.hidden = false
        pauseButton.hidden = true
        coverUpButton.hidden = false
    }
    @IBAction func choice4Clicked(sender: AnyObject) {
        if (checkForRightAnswer(4) == true)
        {
            choice4Button.backgroundColor = UIColor.greenColor()
            numCorrect++
        }
        else
        {
            choice4Button.backgroundColor = UIColor.redColor()
            
            if (checkForRightAnswer(1) == true) {
                choice1Button.backgroundColor = UIColor.greenColor()
            }
            
            else if (checkForRightAnswer(2) == true) {
                choice2Button.backgroundColor = UIColor.greenColor()
            }
            
            else if (checkForRightAnswer(3) == true) {
                choice3Button.backgroundColor = UIColor.greenColor()
            }
        }
        nextButton.hidden = false
        pauseButton.hidden = true
        coverUpButton.hidden = false
    }
    
    @IBAction func nextButtonClicked(sender: AnyObject) {
        
        resetColours()
        changeProgress()
        makeQuestion()
        makeMultipleChoice()
        selectionSort()
        assignToButtons()
        pauseButton.hidden = false
        nextButton.hidden = true
        coverUpButton.hidden = true
        
    }
    
    func changeProgress(){
        numQuestions++
        var temp = Double(numQuestions)/10
        progressMCF.setProgress(Float(temp), animated: true)
        endGame()
    }
    
    func resetColours(){
        choice1Button.backgroundColor = UIColor(red: 222/255.0, green: 168/255.0, blue: 160/255.0, alpha: 1.0)
        choice2Button.backgroundColor = UIColor(red: 205/255.0, green: 86/255.0, blue: 67/255.0, alpha: 1.0)
        choice3Button.backgroundColor = UIColor(red: 222/255.0, green: 168/255.0, blue: 160/255.0, alpha: 1.0)
        choice4Button.backgroundColor = UIColor(red: 205/255.0, green: 86/255.0, blue: 67/255.0, alpha: 1.0)    }
    
    func makeQuestion()
    {
        var temp = "s" + quadraticRelation.generateExpression() + "f"
        
        if var start = temp.rangeOfString("s"), end = temp.rangeOfString("x²")
        {
            firstFactor = temp[start.endIndex..<end.startIndex]
        }
        
        if var start = temp.rangeOfString("e"), end = temp.rangeOfString("f")
        {
            secondFactor = temp[start.endIndex..<end.startIndex]
        }
        
        let indexOfXSquaredChar = temp.lowercaseString.characters.indexOf(Character("x"))
        let indexOfXSquaredInt = temp.startIndex.distanceTo(indexOfXSquaredChar!)
        
        let rangeOne = temp.endIndex.advancedBy((-1 * temp.characters.count))..<temp.endIndex.advancedBy((-1 * Int(temp.characters.count - indexOfXSquaredInt)))
        
        temp.removeRange(rangeOne)
        
        let indexOfLastStringChar = temp.lowercaseString.characters.indexOf(Character("e"))
        let indexOfLastStringInt = temp.startIndex.distanceTo(indexOfLastStringChar!)
        
        let rangeTwo = temp.endIndex.advancedBy((-1 * Int(temp.characters.count - indexOfLastStringInt)))..<temp.endIndex
        
        temp.removeRange(rangeTwo)
        
        question = temp
        
        self.questionLabel.text = question
    }
    
    @IBAction func pauseClicked(sender: AnyObject)
    {
        performSegueWithIdentifier("pauseMCF", sender: sender)
    }
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        var temp = Double(numQuestions)/10
        progressMCF.setProgress(Float(temp), animated: false)
        coverUpButton.hidden = true
        
        if (fromPause == true) {
            questionLabel.text = question
            choice1Button.setTitle(choice[0], forState: .Normal)
            choice2Button.setTitle(choice[1], forState: .Normal)
            choice3Button.setTitle(choice[2], forState: .Normal)
            choice4Button.setTitle(choice[3], forState: .Normal)

        }
        else {
            makeQuestion()
            makeMultipleChoice()
            selectionSort()
            assignToButtons()
        }
        // Do any additional setup after loading the view.
    }

    func selectionSort()
    {
        var rightAns: String = choice [0]
        choice.removeAtIndex(0)
        
        rightAnsIndex = 4 - Int(arc4random_uniform (4) + 1)
        choice.insert(rightAns, atIndex: rightAnsIndex)
    }
    
    func assignToButtons()
    {
        self.choice1Button.setTitle(choice[0], forState: .Normal)
        self.choice2Button.setTitle(choice[1], forState: .Normal)
        self.choice3Button.setTitle(choice[2], forState: .Normal)
        self.choice4Button.setTitle(choice[3], forState: .Normal)
    }
    
    override func didReceiveMemoryWarning()
    {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    func endGame()
    {
        if(numQuestions == 10)
        {
            performSegueWithIdentifier("endMCF", sender: self)
        }
    }

    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!)
    {
        if(segue.identifier == "pauseMCF")
        {
            let pvc = segue.destinationViewController as! PauseViewController
            
            pvc.score = numCorrect
            pvc.numQuestion = numQuestions
            pvc.type = "Multiple Choice Factor"
            pvc.factorOne = firstFactor
            pvc.factorTwo = secondFactor
            pvc.question = question
            pvc.rightAnswerIndex = rightAnsIndex
            
            for (var i = 0; i <= 3; i++){
                pvc.multipleChoiceChoices.insert(choice[i], atIndex: i)
            }
        }
        else if(segue.identifier == "endMCF")
        {
            let evc = segue.destinationViewController as! EndViewController
            evc.numCorrect = numCorrect
            evc.type = "Multiple Choice Factor"
        }
    }

    func checkForRightAnswer(buttonNumber: Int) -> Bool
    {
        if (rightAnsIndex == (buttonNumber - 1))
        {
            return true
        }
        else
        {
            return false
        }
    }
    
    func makeMultipleChoice()
    {
        var finalAns: String = ""
        var i: Int = 0
        var a: Int = 0
        
        var finalChoice = [String]()
        
        for ( a = 0; a <= 3; a++)
        {
            choice.insert("", atIndex: a)
        }
        
        var rAns = multipleChoice()
        var sAns = multipleChoice()
        
        var rS: String = rAns.getRAns(-1 * Int(firstFactor)!)
        var sS: String = sAns.getSAns(-1 * Int(secondFactor)!)
        
        choice.removeAtIndex(0)
        choice.insert("(x"+rS+")(x"+sS+")", atIndex: 0)
        
        finalAns = choice[0]
        
        for ( i = 1; i <= 3; i++)
        {
            
            rAns.r = Int(arc4random_uniform(9) + 1) - Int(arc4random_uniform(9) + 1)
            sAns.s = Int(arc4random_uniform(9) + 1) - Int(arc4random_uniform(9) + 1)
            
            if(rAns.r >= 10 || rAns.r <= -10 || sAns.s >= 10 || sAns.s <= -10)
            {
                
                i--
                
            }
            else
            {
                
                if (choice[i] == "")
                {
                    
                    choice[i] = "(x"+rAns.getRAns(rAns.r)+")(x"+sAns.getSAns(sAns.s)+")"
                    
                    if(choice [i] == choice [0])
                    {
                        choice.removeAtIndex(i)
                        choice.insert("", atIndex: i)
                        i--
                    }
                }
                
            }
            
        
        }
    }
}
